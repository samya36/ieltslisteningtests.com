const standardAnswers = { "section1_1": "reception", "section1_2": "parking", "section1_3": "library", "section1_4": "cafeteria", "section1_5": "gymnasium", "section2_11": ["A", "C"], "section2_12": ["B", "D"], "section2_13": ["A", "B"], "section2_14": ["C", "D"] }; const synonymAnswers = { "reception": ["receptionist"], "parking": ["car park"], "library": ["libraries"], "cafeteria": ["café", "cafe"], "gymnasium": ["gym"] }; const numberMapping = { "one": "1", "two": "2", "three": "3", "four": "4", "five": "5", "six": "6", "seven": "7", "eight": "8", "nine": "9", "ten": "10" }; function normalizeAnswer(answer) { answer = answer.toLowerCase().trim(); if (numberMapping[answer]) { return numberMapping[answer]; } return answer; } function compareFillInBlank(userAnswer, correctAnswer) { const normalizedUserAnswer = normalizeAnswer(userAnswer); const normalizedCorrectAnswer = normalizeAnswer(correctAnswer); if (normalizedUserAnswer === normalizedCorrectAnswer) { return { score: 1, status: "correct" }; } if (synonymAnswers[normalizedCorrectAnswer] && synonymAnswers[normalizedCorrectAnswer].includes(normalizedUserAnswer)) { return { score: 1, status: "correct" }; } const distance = levenshteinDistance(normalizedUserAnswer, normalizedCorrectAnswer); if (distance <= 2) { return { score: 0.8, status: "partial" }; } return { score: 0, status: "incorrect" }; } function compareMultipleChoice(userAnswers, correctAnswers) { if (!Array.isArray(userAnswers) || !Array.isArray(correctAnswers)) { return { score: 0, status: "incorrect" }; } const normalizedUserAnswers = userAnswers.map(normalizeAnswer); const normalizedCorrectAnswers = correctAnswers.map(normalizeAnswer); let correctCount = 0; normalizedUserAnswers.forEach(answer => { if (normalizedCorrectAnswers.includes(answer)) { correctCount++; } }); const score = correctCount * 0.5; let status; if (score === 1) { status = "correct"; } else if (score > 0) { status = "partial"; } else { status = "incorrect"; } return { score, status }; } function calculateEnhancedScore(userAnswers) { const result = { totalScore: 0, sectionScores: { section1: 0, section2: 0, section3: 0 }, sectionAnalysis: { section1: [], section2: [], section3: [] }, problemAreas: [] }; for (let section = 1; section <= 3; section++) { const sectionKey = `section${section}`; let sectionScore = 0; const sectionQuestions = Object.keys(userAnswers).filter(key => key.startsWith(sectionKey)); sectionQuestions.forEach(questionKey => { const userAnswer = userAnswers[questionKey]; const correctAnswer = standardAnswers[questionKey]; let questionResult; if (section === 1) { questionResult = compareFillInBlank(userAnswer, correctAnswer); } else { questionResult = compareMultipleChoice(userAnswer, correctAnswer); } sectionScore += questionResult.score; result.sectionAnalysis[sectionKey].push({ questionNumber: questionKey.split("_")[1], userAnswer: Array.isArray(userAnswer) ? userAnswer.join(", ") : userAnswer, correctAnswer: Array.isArray(correctAnswer) ? correctAnswer.join(", ") : correctAnswer, status: questionResult.status, score: questionResult.score }); }); result.sectionScores[sectionKey] = sectionScore; result.totalScore += sectionScore; } result.problemAreas = findProblemAreas(result.sectionAnalysis); return result; } function findProblemAreas(sectionAnalysis) { const problemAreas = []; const spellingErrors = []; Object.values(sectionAnalysis).forEach(section => { section.forEach(question => { if (question.status === "partial" && levenshteinDistance(question.userAnswer, question.correctAnswer) <= 2) { spellingErrors.push(question.questionNumber); } }); }); if (spellingErrors.length > 0) { problemAreas.push(`您在第 ${spellingErrors.join(", ")} 题存在拼写错误，建议加强拼写练习。`); } Object.entries(sectionAnalysis).forEach(([section, questions]) => { const partialScores = questions.filter(q => q.status === "partial"); if (partialScores.length > 0) { problemAreas.push(`${section} 中有 ${partialScores.length} 道题部分正确，需要加强相关题型的练习。`); } }); Object.entries(sectionAnalysis).forEach(([section, questions]) => { const incorrectScores = questions.filter(q => q.status === "incorrect"); if (incorrectScores.length > 0) { problemAreas.push(`${section} 中有 ${incorrectScores.length} 道题完全错误，建议重新学习相关知识点。`); } }); return problemAreas; } function levenshteinDistance(str1, str2) { const matrix = []; for (let i = 0; i <= str1.length; i++) { matrix[i] = [i]; } for (let j = 0; j <= str2.length; j++) { matrix[0][j] = j; } for (let i = 1; i <= str1.length; i++) { for (let j = 1; j <= str2.length; j++) { if (str1[i - 1] === str2[j - 1]) { matrix[i][j] = matrix[i - 1][j - 1]; } else { matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1); } } } return matrix[str1.length][str2.length]; } export { calculateEnhancedScore };
